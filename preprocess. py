import os
import glob
import argparse
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from openvino.runtime import Core
from tqdm import tqdm
from PIL import Image
import shutil

# --- CONFIG ---
BATCH_SIZE = 32 # Higher = Faster CPU processing

class PatchDataset(Dataset):
    def __init__(self, file_list, transform=None):
        self.files = file_list
        self.transform = transform
    def __len__(self): return len(self.files)
    def __getitem__(self, idx):
        path = self.files[idx]
        try:
            with Image.open(path) as img:
                return self.transform(img.convert('RGB')), path
        except:
            return torch.zeros(3, 224, 224), path

def get_openvino_model(xml_path, bin_path):
    ie = Core()
    model = ie.read_model(model=xml_path, weights=bin_path)
    # Enable dynamic batching for efficiency
    model.reshape([-1, 3, 224, 224])
    compiled_model = ie.compile_model(model=model, device_name="CPU")
    return compiled_model, compiled_model.output(0)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--data_dir", type=str, required=True) # e.g. ./train_patches_10000/train
    parser.add_argument("--output_dir", type=str, required=True) # e.g. ./features_data/train
    parser.add_argument("--xml_path", type=str, required=True)
    parser.add_argument("--bin_path", type=str, required=True)
    args = parser.parse_args()

    # 1. Setup OpenVINO
    print("--> Loading OpenVINO Model...")
    net, output_layer = get_openvino_model(args.xml_path, args.bin_path)

    # 2. Setup Transform
    tfm = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    # 3. Scan Classes
    classes = sorted([d for d in os.listdir(args.data_dir) if os.path.isdir(os.path.join(args.data_dir, d))])
    print(f"--> Found {len(classes)} classes. Starting extraction...")

    for cls in classes:
        src_folder = os.path.join(args.data_dir, cls)
        dst_folder = os.path.join(args.output_dir, cls)
        os.makedirs(dst_folder, exist_ok=True)
        
        # Group by Prescription ID
        all_imgs = glob.glob(os.path.join(src_folder, "*.jpg"))
        rx_map = {}
        for p in all_imgs:
            # Logic: "Amox_Rx1_patch_0.jpg" -> "Amox_Rx1"
            rx_id = os.path.basename(p).split('_patch_')[0]
            if rx_id not in rx_map: rx_map[rx_id] = []
            rx_map[rx_id].append(p)
            
        print(f"Processing {cls}: {len(rx_map)} prescriptions...")
        
        for rx_id, paths in tqdm(rx_map.items(), leave=False):
            # Check if already done
            save_path = os.path.join(dst_folder, rx_id + ".pt")
            if os.path.exists(save_path): continue

            # Create Mini-Loader for this one prescription
            ds = PatchDataset(paths, transform=tfm)
            loader = DataLoader(ds, batch_size=BATCH_SIZE, num_workers=4)
            
            features_list = []
            
            for imgs, _ in loader:
                # OpenVINO Inference
                imgs_np = imgs.numpy()
                res = net([imgs_np])[output_layer]
                feat = torch.from_numpy(res)
                
                # Flatten [B, C, 1, 1] -> [B, C]
                if len(feat.shape) == 4: feat = feat.view(feat.size(0), -1)
                features_list.append(feat)
            
            if len(features_list) > 0:
                full_tensor = torch.cat(features_list, dim=0) # [Num_Pills, 512]
                torch.save(full_tensor, save_path) # Save small tensor file

    print("\n--> Feature Extraction Complete!")
    print(f"--> Data saved to {args.output_dir}")

if __name__ == "__main__":
    main()
